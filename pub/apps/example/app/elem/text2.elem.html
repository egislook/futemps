<elem-text2>

  <div
    if={false}
    placeholder="{ placeholder }"
    contentEditable="{ opts.contentEditable || contentEditable }"
    class="{ opts.class } {
      'ws:pl ww:nm bd-l:sd-1px-ts fc-bd-c:prim fc-p-l:5px fux-trans bd-r-w:1px bd-c:ts fc-bg:white fc-c:black' : !opts.noBasicClass,
      'c:err fc-bd-c:err' : !isValid,
    }"
    onclick="{ opts.editMode && !contentEditable && handleSetEditable }"
    onblur="{ handleUpdateEditable }"
    onkeyup="{ handletempTextLength }"
    onmouseup="{ opts.editorEnabled && handleDisplayEditor }">Editable</div>

  <div ref="container" class={opts.class}>
    <yield />
  </div>

  <a
    data-uneditable="true"
    ref="editor"
    class="dp:ib ps:ab p:10px br:5px-2px-0-5px c:white z:10 op:0.9 fux-trans fux-fadeIn fux-boxsh {'bg:prim': textIsValid, 'bg:grey200 c:grey': !textIsValid }"
    style={editorPos}>
      <span class="ps:ab t,l:0 fs:70pc fw:600 p:0-2px-1px-1px br:3px-0-50pc-0 fux-boxsh {'bg:white c:black300': textIsValid, 'bg:err c:white': !textIsValid }">
        { getValidtempTextLength() }
      </span>
      <span class="fs:130pc {'fu-check': textIsValid, 'fu-esc': !textIsValid}" />
  </a>

  <script>
    const defaultEditorPos  = { left: '50%', top: '-50%' };
    const defaultTextLimits = { min: 4, max: 520 };
    const self = Object.assign(this, {
      contentEditable:  opts.contentEditable  || true,
      defaultClass:     opts.defaultClass     || 'ws:pl ww:nm bd-r-w:1px bd-c:ts fc-bd-c:prim fc-bg:white fc-c:black fux-trans',
      activeClass:      opts.activeClass      || 'fux-boxsh',
      onDone:           opts.onDone           || ((value, id) => console.log('onEdit', value, id)),
      placeholder:      'enter text',
      tempText:         null,
      tempTextLength:   0,
      editorPos:        defaultEditorPos,
      enterEditDone:    null,
      focusTimer:       null,
      textLimits:       defaultTextLimits,
      textIsValid:      null,
    });

    this.getValidtempTextLength = () => {
      if(this.textIsValid)
        return this.tempTextLength;

      if(this.tempTextLength < this.textLimits.min)
        return this.textLimits.min - this.tempTextLength;

      if(this.tempTextLength > this.textLimits.max)
        return this.textLimits.max - this.tempTextLength;
    }

    this.on('mount', () => {

      const container = this.refs.container;

      for(let i in container.children){
        let child = container.children[i];
        if(typeof child !== 'object')
          break;
        if(child.dataset['uneditable'])
          break;

        let classList = this.defaultClass.split(' ');
        child.classList.add(...classList);
        child.contentEditable = 'plaintext-only';
        child.spellcheck = false;
        //child.onclick   = this.handleForceFocus.bind(this);
        child.onclick   = this.handleClick.bind(this);
        child.onfocus   = this.handleStartEditing.bind(this);//this.handleStartEditing.bind(this);
        child.onkeyup   = this.handleEditing.bind(this);
        child.onkeydown = this.handleBeforeEditing.bind(this);
        child.onblur    = this.handleEndEditing.bind(this, child.dataset['path'] || child.dataset['id']);
        //child.onclick = this.handleClick.bind(this);
        !child.getAttribute('placeholder') && child.setAttribute('placeholder', this.placeholder);
        container.children[i] = child;
      }
    })

    this.handleForceFocus = (e) => {
      e.target.contentEditable = 'plaintext-only';
      e.target.focus();
    }

    this.getEditorPosByCaret = (elem) => {

      // window.pageYOffset window.scrollY
      const selection   = document.getSelection();
      const bound       = elem.getBoundingClientRect();
      const editorElem  = this.refs.editor;

      let editorPos = {
        left: (elem.offsetLeft + bound.width - editorElem.offsetWidth) + 'px',
        //top:  elem.offsetTop + 20 + 'px',
        top: bound.top + window.scrollY + 'px'
      }

      // if(!this.tempText)
      //   return editorPos;

      let oRange = selection.getRangeAt(0);
      let oRect = oRange.getBoundingClientRect();
      //console.log(oRange.offsetTop, oRect);
      //bug of position when line is empty
      editorPos.top = oRect.top
        ? (oRect.top + window.scrollY - editorElem.offsetHeight) + 'px'
        : this.editorPos.top;
      return editorPos;
    }

    this.handleStartEditing = (e) => {
      clearTimeout(this.focusTimer);
      e.target.contentEditable = 'plaintext-only';
      e.target.classList.add(...this.activeClass.split(' '));
      const tempText = e.target.textContent.trim() || '';
      //this.editorPos = this.getEditorPosByCaret(e.target);
      this.tempText     = tempText;
      this.tempTextLength   = tempText.length;
      this.textIsValid  = this.textLimits.min < this.tempTextLength && this.textLimits.max > this.tempTextLength;
  	}

    this.handleBeforeEditing = (e) => {
      switch(e.keyCode){
        case 27:
          e.target.innerText = this.tempText;
          return e.target.blur();
        break;
      }

    }

    this.handleEditing = (e) => {
      const tempTextLength = e.target.textContent.trim().length;
      this.update({
        tempTextLength,
        editorPos:    this.getEditorPosByCaret(e.target),
        textIsValid:  this.textLimits.min <= tempTextLength && this.textLimits.max >= tempTextLength,
      });
  	  // tag.isValid = tag.handleIsValid(text);
    }

    this.handleEndEditing = (path, e) => {
      let text = e.target.innerText.trim();
      e.target.classList.remove(...this.activeClass.split(' '));

      if(!this.textIsValid)
        e.target.innerText = this.tempText;
      else{
        if(text !== this.tempText)
          this.onDone(text, path);

        e.target.innerText = e.target.innerText;
        //window.getSelection().removeAllRanges();
      }
      this.focusTimer = setTimeout(
        () => this.update({ tempText: null, editorPos: defaultEditorPos }),
        100);
    }

    this.handleClick = (e) => {
      this.update({ editorPos: this.getEditorPosByCaret(e.target) });
    }

  </script>

</elem-text2>
